// ==============================
// ---- High-Level Structure ----
// ==============================

// supports top-level global declarations/initial assignments and probe definitions
script = { SOI ~ statement* ~ probe_def+ ~ EOI }

// TODO -- support comma separated list of specs: https://docs.oracle.com/cd/E23824_01/html/E22973/glghi.html#scrolltoc
probe_def = { PROBE_SPEC ~ PUSH(predicate?) ~ "{" ~ statement* ~ "}" }

predicate = { "/" ~ expr ~ "/" }

// =====================
// ---- Identifiers ----
// =====================

PROBE_ID = @{
    (ASCII_ALPHA
    | "_"
    | ASCII_DIGIT
    | "*"
    | "+"
    | "\\"
    | "?"
    | "|"
    | "!"
    | "["
    | "]")+
}

// TODO -- I think we only want the one that has all three colons, or a single PROBE_ID
PROBE_SPEC = ${
    PROBE_ID? ~ ":" ~ PROBE_ID? ~ ":" ~ PROBE_ID? ~ ":" ~ PROBE_ID?
    | PROBE_ID? ~ ":" ~ PROBE_ID? ~ ":" ~ PROBE_ID?
    | PROBE_ID? ~ ":" ~ PROBE_ID?
    | PROBE_ID
}

ID = @{ (ASCII_ALPHA | "_")+ ~ ( ASCII_DIGIT | (ASCII_ALPHA | "_")+ )* }

// ===============
// ---- Types ----
// ===============

TY_INT = @{ "i32" }
TY_BOOL = @{ "bool" }
TY_STRING = @{ "str" }

// a tuple that's used as a type declaration
TY_TUPLE = { "(" ~ TYPE ~ ( "," ~ TYPE )* ~ ")" }
// first TYPE is the type of the key, second TYPE is the type of the value
TY_MAP = { "map<" ~ TYPE ~ "," ~ TYPE ~ ">" }

TYPE = _{ TY_INT | TY_BOOL | TY_STRING | TY_TUPLE | TY_MAP }

// ====================
// ---- Statements ----
// ====================

arg = { tuple | expr | val }
fn_call = { ID ~ "(" ~ ( arg )? ~ ( "," ~ arg )* ~ ")" }

// var ops
declaration = { TYPE ~ ID }
assignment = { ID ~ "=" ~ (ternary | expr) }
statement = { ( ( declaration | assignment | fn_call ) ~ ";" )+ }

// =====================
// ---- Expressions ----
// =====================

ternary = { expr ~ "?" ~ expr ~ ":" ~ expr }

expr = { prefix? ~ operand ~ (BINOP ~ prefix? ~ operand)* }

prefix = _{ UNOP }
UNOP = _{ neg }
    neg = { "!" }

val = _{ BOOL | ID | INT | STRING }
operand = _{ fn_call | "(" ~ expr ~ ")" | val }

tuple = { "(" ~ (val) ~ ( "," ~ val )* ~ ")" }

BINOP = _{ LOGOP | RELOP | SUMOP | MULOP }
    // Logical operators
    and = { "&&" }
    or = { "||" }
    LOGOP = _{ and | or }

    // Relational operators
    eq = { "==" }
    ne = { "!=" }
    ge = { ">=" }
    gt = { ">" }
    le = { "<=" }
    lt = { "<" }
    RELOP = _{ eq | ne | ge | gt | le | lt }

    // Highest precedence arithmetic operators
    add = { "+" }
    subtract = { "-" }
    SUMOP = _{ add | subtract }

    // Next highest precedence arithmetic operators
    multiply = { "*" }
    divide = { "/" }
    modulo = { "%" }
    MULOP = _{ multiply | divide | modulo }

// ===================
// ---- Terminals ----
// ===================

// TODO -- make sure that the binary/octal/hexadecimal formats are parsed correctly
// TODO -- add support for negative numbers (see calc-pest tutorial)
INT = @{
    "0x" ~ ASCII_HEX_DIGIT+ // Hexadecimal digit
    | "0b" ~ ASCII_BIN_DIGIT+ // Binary digit
    | "0" ~ ASCII_OCT_DIGIT+ // Octal digit
    | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT+ // Multiple digit, base 10
    | ASCII_DIGIT // Single digit, base 10 (account for having just '0')
}

BOOL = @{
    "true"
    | "false"
}

STRING = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// ===================
// ---- Skip-able ----
// ===================

newline = _{ "\n" | "\r\n" }
WHITESPACE = _{ " " | "\t" | newline }

block_comment = _{ "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }
COMMENT    = _{ block_comment | ("//" ~ (!newline ~ ANY)*) }
