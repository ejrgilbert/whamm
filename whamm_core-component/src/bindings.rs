// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_putc_wrap_cabi<T: Guest>(arg0: i32) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::putc_wrap(arg0 as u8);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_puts_wrap_cabi<T: Guest>(arg0: i32, arg1: i32) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::puts_wrap(arg0 as u32, arg1 as u32);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_putu8_wrap_cabi<T: Guest>(arg0: i32) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::putu8_wrap(arg0 as u8);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_puti8_wrap_cabi<T: Guest>(arg0: i32) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::puti8_wrap(arg0 as i8);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_putu16_wrap_cabi<T: Guest>(arg0: i32) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::putu16_wrap(arg0 as u16);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_puti16_wrap_cabi<T: Guest>(arg0: i32) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::puti16_wrap(arg0 as i16);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_putu32_wrap_cabi<T: Guest>(arg0: i32) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::putu32_wrap(arg0 as u32);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_puti32_wrap_cabi<T: Guest>(arg0: i32) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::puti32_wrap(arg0);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_putu64_wrap_cabi<T: Guest>(arg0: i64) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::putu64_wrap(arg0 as u64);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_puti64_wrap_cabi<T: Guest>(arg0: i64) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::puti64_wrap(arg0);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_putf32_wrap_cabi<T: Guest>(arg0: f32) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::putf32_wrap(arg0);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_putf64_wrap_cabi<T: Guest>(arg0: f64) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::putf64_wrap(arg0);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_putbool_wrap_cabi<T: Guest>(arg0: i32) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    T::putbool_wrap(arg0 as u8);
}
pub trait Guest {
    /// =============
    /// ==== I/O ====
    /// =============
    fn putc_wrap(c: u8) -> ();
    fn puts_wrap(a: u32, l: u32) -> ();
    fn putu8_wrap(u: u8) -> ();
    fn puti8_wrap(i: i8) -> ();
    fn putu16_wrap(u: u16) -> ();
    fn puti16_wrap(i: i16) -> ();
    fn putu32_wrap(u: u32) -> ();
    fn puti32_wrap(i: i32) -> ();
    fn putu64_wrap(u: u64) -> ();
    fn puti64_wrap(i: i64) -> ();
    fn putf32_wrap(f: f32) -> ();
    fn putf64_wrap(f: f64) -> ();
    fn putbool_wrap(u: u8) -> ();
}
#[doc(hidden)]
macro_rules! __export_world_support_lib_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[unsafe (export_name = "putc-wrap")] unsafe extern "C" fn
        export_putc_wrap(arg0 : i32,) { unsafe { $($path_to_types)*::
        _export_putc_wrap_cabi::<$ty > (arg0) } } #[unsafe (export_name = "puts-wrap")]
        unsafe extern "C" fn export_puts_wrap(arg0 : i32, arg1 : i32,) { unsafe {
        $($path_to_types)*:: _export_puts_wrap_cabi::<$ty > (arg0, arg1) } } #[unsafe
        (export_name = "putu8-wrap")] unsafe extern "C" fn export_putu8_wrap(arg0 : i32,)
        { unsafe { $($path_to_types)*:: _export_putu8_wrap_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "puti8-wrap")] unsafe extern "C" fn
        export_puti8_wrap(arg0 : i32,) { unsafe { $($path_to_types)*::
        _export_puti8_wrap_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "putu16-wrap")] unsafe extern "C" fn export_putu16_wrap(arg0 : i32,) { unsafe {
        $($path_to_types)*:: _export_putu16_wrap_cabi::<$ty > (arg0) } } #[unsafe
        (export_name = "puti16-wrap")] unsafe extern "C" fn export_puti16_wrap(arg0 :
        i32,) { unsafe { $($path_to_types)*:: _export_puti16_wrap_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "putu32-wrap")] unsafe extern "C" fn
        export_putu32_wrap(arg0 : i32,) { unsafe { $($path_to_types)*::
        _export_putu32_wrap_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "puti32-wrap")] unsafe extern "C" fn export_puti32_wrap(arg0 : i32,) { unsafe {
        $($path_to_types)*:: _export_puti32_wrap_cabi::<$ty > (arg0) } } #[unsafe
        (export_name = "putu64-wrap")] unsafe extern "C" fn export_putu64_wrap(arg0 :
        i64,) { unsafe { $($path_to_types)*:: _export_putu64_wrap_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "puti64-wrap")] unsafe extern "C" fn
        export_puti64_wrap(arg0 : i64,) { unsafe { $($path_to_types)*::
        _export_puti64_wrap_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "putf32-wrap")] unsafe extern "C" fn export_putf32_wrap(arg0 : f32,) { unsafe {
        $($path_to_types)*:: _export_putf32_wrap_cabi::<$ty > (arg0) } } #[unsafe
        (export_name = "putf64-wrap")] unsafe extern "C" fn export_putf64_wrap(arg0 :
        f64,) { unsafe { $($path_to_types)*:: _export_putf64_wrap_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "putbool-wrap")] unsafe extern "C" fn
        export_putbool_wrap(arg0 : i32,) { unsafe { $($path_to_types)*::
        _export_putbool_wrap_cabi::<$ty > (arg0) } } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_support_lib_cabi;
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_support_lib_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_support_lib_cabi!($ty with_types_in
        $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_support_lib_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:component:whamm-core:support-lib:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 475] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd9\x02\x01A\x02\x01\
A\x19\x01@\x01\x01c}\x01\0\x04\0\x09putc-wrap\x01\0\x01@\x02\x01ay\x01ly\x01\0\x04\
\0\x09puts-wrap\x01\x01\x01@\x01\x01u}\x01\0\x04\0\x0aputu8-wrap\x01\x02\x01@\x01\
\x01i~\x01\0\x04\0\x0aputi8-wrap\x01\x03\x01@\x01\x01u{\x01\0\x04\0\x0bputu16-wr\
ap\x01\x04\x01@\x01\x01i|\x01\0\x04\0\x0bputi16-wrap\x01\x05\x01@\x01\x01uy\x01\0\
\x04\0\x0bputu32-wrap\x01\x06\x01@\x01\x01iz\x01\0\x04\0\x0bputi32-wrap\x01\x07\x01\
@\x01\x01uw\x01\0\x04\0\x0bputu64-wrap\x01\x08\x01@\x01\x01ix\x01\0\x04\0\x0bput\
i64-wrap\x01\x09\x01@\x01\x01fv\x01\0\x04\0\x0bputf32-wrap\x01\x0a\x01@\x01\x01f\
u\x01\0\x04\0\x0bputf64-wrap\x01\x0b\x04\0\x0cputbool-wrap\x01\x02\x04\0\x20comp\
onent:whamm-core/support-lib\x04\0\x0b\x11\x01\0\x0bsupport-lib\x03\0\0\0G\x09pr\
oducers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x06\
0.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
